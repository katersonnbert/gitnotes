Python 3
========

__REME__ ... things to read again and again!


# Python style guide and documentation conventions:

## style guide crash course

	https://gist.github.com/sloria/7001839

## Style guide Pep:

	https://www.python.org/dev/peps/pep-0008/

## Docstring Pep:

	https://www.python.org/dev/peps/pep-0257/


# Magic variable ```_```

In interactive mode, the magic variable ```_``` always returns the last value printed to the console.


# Comments

The hash character is used to add comments to code:
	```
	# comment 1
	var = 1 # comment 2
			# comment 3
	```

Triple single quotes are used for multi line comments.
	```
	'''
	multi
	line
	comment
	'''
	```

# Numbers in Python:
	```
	1/2 	# division always returns float
	1//2	# floor division, returns int
	1%2		# division remainder, returns int (?)
	2**3	# power of
	```
Python supports
- int
- float
- Decimal
- Fraction
- complex numbers


# Strings in Python:

- Strings can be enclosed by single '...' or double "..." quotes.
- Special characters are escaped by the backslash character \
- ```\n``` produces a new line
- using ```r``` before a string prevents special character escape
	```
	print('C:\name\path')	# will print "C:" [new line] "ame\path"
	print(r'C:\name\path')	# will print "C:\name\path"
	```
- multi line strings are defined by using triple-quotes '''...''' or """..."""
	```
	"""
	Write multiple
	Lines of
	String
	"""
	```
- Strings can be concatenated by the '+' operator
	```
	lang = 'Py' + 'thon'	# lang contains 'Python'
	```
- Strings can be repeated
	```
	food = 2 * 'yum'		# food contains 'yumyum'
	```
- Strings can be treated as arrays:
	```
	word = 'Python'
	word[0]				# returns 'P'
	word[-1]			# returns the last character 'n'
	word[-2]			# returns the second last character 'o'
	word[0:2]			# slicing returns the characters from inclusive 0 to exclusive 2 'Py'
	```
__REME__
NOTE: Python strings are immuatable! ```word[0] = "X"``` will fail
NOTE: When slicing the left index is always in- the right always excluded.

- ```len(s)	# returns the length of a string.```


# Lists in Python:

- A Python List is a compound data type.
- Contains comma separated values.
- Can contain values of different types.
	```
	squares = [1, 4, 9, 16, 25]
	```
- Can be indexed and sliced.
	```
	squares[0]		# returns 1
	squares[-3:]	# returns [9, 16, 25], slicing returns a new list
	```
- Lists are mutable, their values can be changed.
	```
	squares[0] = 5	# changes content of the list from [1, 4, 9, 16, 25] to [5, 4, 9, 16, 25]
	```
- Lists can be nested
	```
	one = [1, 2, 3]
	two = ['a', 'b', 'c']
	many = [one, two]
	```
- ```list.append()		# appends new items to the end of a list.```
- ```len(list)			# returns the length of a list.```


# Control structures:

## if statement:
	```
	if [condition]:
		[execute code]
	elif [condition]:
		[execute code]
	else:
		[execute code]
	```

## while statement:
	```
	while [condition]:
		[execute code]
	```

## for statement:

- The Python ```for``` statement provides the iteration over the items of any sequence (list or string).
- The ```range()``` function generates arithmetic progressions; it provides additional starting points and different steps of progression.
	```
	for i in range(5):
		print(i, end=', ')		# prints 0, 1, 2, 3, 4, 
	```
- The ```break``` keyword ends a ```for``` statement prematurely.
- The ```for``` statement can be used with an ```else``` clause.
	```
	for n in range(2, 10):
		for x in range(2, n):
			if n % x == 0:
				print(n, 'equals', x, '*', n//x)
				break
		else:
			print(n, 'is a prime number')
	```
- The ```continue``` keyword in the body of a for statement ends the current iteration, ignores any following code and continues with the next
	element of the ```for``` statement.
	```
	for num in range(2, 10):
		if num % 2 == 0:
			print("Found an even number", num)
			continue
		print("Found a number", num)
	```

# Functions:

- The keyword ```def``` introduces a function definition.
- Function names should be lower case, words should be separated by underscores.
- Always use ```self``` for the first argument to instance methods.
- Always use ```cls``` for the first argument to class methods.
- The first statement of the function body can be a string literal. If existent, this literal is the documentation string of the function.
	```
	def print_me(s):
		"""Print the text that is provided to the function"""
		print("I will print: ", s)

	print_me("me")		# prints "I will print: me"
	```

## Execution of a function
__REME__block
- A function definition introduces the function name to the current local symbol table.
- When a function is executed, a new symbol table is created used for the local variables of this function.
- Variable references always look up the values in the following order:
	1) local symbol table
	2) local symbol tables of enclosing functions
	3) global symbol table
	4) table of built-in names
- Global variables cannot be directly assigned with a value within a function!
- Arguments of a function are introduced into the newly created symbol table. Their value is always an object reference, never a value of the object!
- Functions without a ```return``` keyword return value ```None```
- Not executed function calls return a reference to this function in the local symbol table and can be used to assign it to another name:
	```
	print_me		# prints '<function print_me at [memoryaddress]>'
	p = print_me
	p("I shall be printed")		# will print the provided string
	```
__REME__end


## Function arguments
There are distinct types of function arguments:
- required arguments
- positional arguments
- keyword arguments
- optional arguments = arguments with default value
- variadic arguments


## Variable number of arguments and default arguments

- Within the defintion of a function, default values of arguments can be defined
	```
	def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
		[function body]
	```
__REME__
- PITFALL NOTE: The default value of a function argument is evaluated only once. When the default is a mutable object, this can lead to unexpected behavior, e.g.:
	```
	def f(a, L=[]):
		L.append(a)
		return L

	print(f(1))		# prints [1]
	print(f(2))		# prints [1, 2]
	print(f(3))		# prints [1, 2, 3]
	```
	


## Required function arguments
	A required argument has no default value
	```
	def f(req_arg, def_arg='def_val'):
		[function body]
	```

Can be passed as
- keyword arguments
- positional arguments

- keyword arguments are passed as [identifier]=[value]
	```
	def cat(legs, tail, whiskers):
		[function body]

	cat(tail=1, whiskers='yes, has them', legs=4)
	```

## Arbitrary Argument Lists

- A function can be called with an arbitrary number of arguments (called varadic arguments), denoted by ```*args```.
- Variadic arguments will be wrapped in a Tuple.
	```
	def write_multiple_items(file, separator, *args):
		file.write(separator.join(args))
	```
- Any arguments defined after the variadic argument can only be used as keyword arguments.
	```
	def concat(*args, sep="-"):
		return sep.join(args)
	```
- Lists can be handed as arbitrary arguments list using the ```*``` operator, dicts using ```**```
	```
	l = ['1', '2', '3', '4']
	concat(*l)

	def concat_four(one, two, three, four='string'):
		print(one +" "+ two +" "+ three +" "+ four)

	d = {"one": "Concatenate", "two": "this", "three": "wonderful"}
	concat_four(**d)
	```

# Lambda expressions

- Lambda expressions are small, anonymous functions.
- They can be used via the ```lambda``` keyword.
- Lambdas can reference variables from the containing scope.
	```
	def make_incrementor(n):
		return lambda x: x + n
	```
- Lambdas can be used to pass small functions as arguments into a function
	```
	pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
	pairs.sort(key=lambda pair: pair[1])
	```

# Annotating function argument and return types

- Function argument and return types can be annotated in the function definition.
- ```->``` denotes the return type
- Annotating types is completely optional
- Annotations are stored in the __annotations__ attribute of the function as a dict.
	```
	def f(ham: str, eggs: str = 'eggs') -> str:
	    print("Annotations:", f.__annotations__)
	```

# Data Structures

## List comprehensions
- Easy method to obtain lists where operations have been performed on each member
- List comprehensions are square brackets containing at least (but not limited to) one ```for``` clause. 
	```
	squares = [x**2 for x in range(10)]

	[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
	# abbreviation for:
	combs = []
	for x in [1,2,3]:
	    for y in [3,1,4]:
	        if x != y:
	            combs.append((x, y))
	```
- List comprehensions can also be used with nested lists.


## Tuples
- A tuple consists of a number of values, separated by commas.
- Contents of a tuple can be accessed by index.
- Tuples can be nested by using parenthesis.
- __REME__ NOTE: contents of a tuple are immutable! (but they can contain lists which elements are mutable again...)
	```
	t = 12345, 54321, 'hello!'	# would print (12345, 54321, 'hello!')
	u = t, (1, 2, 3, 4, 5)		# would print ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
	```
- Tuples are mainly used for heterogenious elements.
- __REME__ NOTE: A tuple with a single element can only be created with the element followed by a single, trailing comma!
	```
	singleton = 'hello',
	```
- elements can be extracted into variables from a tuple in the reverse packing syntax.
	```
	x, y, z = t
	```

## Sets
__REME__
- A set is an unordered collection.
- Sets must not contain duplicate elements - duplicate entries are automatically discarded.
- Sets support union ```|```, intersection ```&```, difference ```-```, symmetric difference ```^```.
- Sets are created by using curly braces; empty sets have to be created by using set()
	```
	basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
	'orange' in basket		# returns True
	'crabgrass' in basket	# returns False
	```
- similar to list comprehension, set comprehension is supported
	```
	a = {x for x in 'abracadabra' if x not in 'abc'}
	```

## Dictionaries
- Set of unordered key : value pairs, separated by commas.
- Keys have to be unique and be of an immutable type like string or number.
- Dictionaries are indexed by keys.
- Dictionaries support comprehensions.
- Dictionaries can be looped using the dict.items() method.


# Modules
- Files with the ending '.py' can contain one or more function definitions. The content of these files can be imported by using the name of the file after an import statement.
- __REME__ Importing a module introduces only the module name to the current symbol table. Functions from the module can be accessed from this reference.
- A star import imports all functions not beginning with an underscore. (star import should not be used though anyway)
- When a module is changed on the fly, the interpreter has to re-import this module.


## Modules as script
- Modules can be run as scripts.
	```
	python mymodule.py <arguments>
	```
- __REME__ The __name__ of an executed module will be changed to "__main__". Adding ```if __name__ == "__main__"``` makes it usable as a script as well as an importable module.


## Module search path
- When a module is imported, the interpreter first looks up its name for a built-in module.
- If nothing is found, the search includes directories given in ```sys.path```. This includes
-- the directory of the input script or the current directory if it has been changed.
-- PYTHONPATH ... The default search path is installation dependent, but generally begins with prefix/lib/pythonversion


## Python compiled files
__REME__
- Compiled python modules are cached in the __pycache__ directory with name 'module.version.pyc' where version is the python version used to compile.
- Switches can be used to reduce the file size of compile python files. '-0' removes assert statements and docstrings.


https://docs.python.org/3/tutorial/modules.html#standard-modules



# Methods

- Methods are functions that belong to an object and are named in the fashion ```obj.methodname```.





# Resources used:
https://docs.python.org/3/tutorial



